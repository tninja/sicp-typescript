// Exercise 1.14: Draw the tree illustrating the process generated by the count-change procedure of 
// section 1.2.2 in making change for 11 cents. What are the orders of growth of the space and number 
// of steps used by this process as the amount to be changed increases?

// Original Scheme code:
// (define (count-change amount)
//   (cc amount 5))
// (define (cc amount kinds-of-coins)
//   (cond ((= amount 0) 1)
//         ((or (< amount 0) (= kinds-of-coins 0)) 0)
//         (else (+ (cc amount
//                      (- kinds-of-coins 1))
//                  (cc (- amount
//                         (first-denomination kinds-of-coins))
//                      kinds-of-coins)))))
// (define (first-denomination kinds-of-coins)
//   (cond ((= kinds-of-coins 1) 1)
//         ((= kinds-of-coins 2) 5)
//         ((= kinds-of-coins 3) 10)
//         ((= kinds-of-coins 4) 25)
//         ((= kinds-of-coins 5) 50)))

import { countChange, cc, firstDenomination } from './1.2';

// Helper to count recursive calls
export const countChangeWithStats = (amount: number): { ways: number; calls: number } => {
    let callCount = 0;
    
    const ccWithCount = (amt: number, kinds: number): number => {
        callCount++;
        if (amt === 0) return 1;
        if (amt < 0 || kinds === 0) return 0;
        return ccWithCount(amt, kinds - 1) + 
               ccWithCount(amt - firstDenomination(kinds), kinds);
    };
    
    const ways = ccWithCount(amount, 5);
    return { ways, calls: callCount };
};

// Generate tree representation for amount = 11
export const generateTreeFor11 = (): string[] => {
    const steps: string[] = [];
    
    steps.push('Recursive call tree for count-change(11):');
    steps.push('(cc 11 5)');
    steps.push('├─ (+ (cc 11 4) (cc -39 5))');
    steps.push('│  ├─ (cc 11 4)');
    steps.push('│  │  ├─ (+ (cc 11 3) (cc -14 4))');
    steps.push('│  │  │  ├─ (cc 11 3)');
    steps.push('│  │  │  │  ├─ (+ (cc 11 2) (cc 1 3))');
    steps.push('│  │  │  │  │  ├─ (cc 11 2)');
    steps.push('│  │  │  │  │  │  ├─ (+ (cc 11 1) (cc 6 2))');
    steps.push('│  │  │  │  │  │  │  ├─ (cc 11 1)');
    steps.push('│  │  │  │  │  │  │  │  ├─ (+ (cc 11 0) (cc 10 1))');
    steps.push('│  │  │  │  │  │  │  │  │  ├─ (cc 11 0) → 0');
    steps.push('│  │  │  │  │  │  │  │  │  └─ (cc 10 1)');
    steps.push('│  │  │  │  │  │  │  │  │     ├─ (+ (cc 10 0) (cc 9 1))');
    steps.push('│  │  │  │  │  │  │  │  │     │  ... continues until (cc 0 1) → 1');
    steps.push('│  │  │  │  │  │  │  │  └─ ...');
    steps.push('│  │  │  │  │  │  │  └─ (cc 6 2)');
    steps.push('│  │  │  │  │  │  │     ...');
    steps.push('│  │  │  │  │  │  └─ ...');
    steps.push('│  │  │  │  │  └─ (cc 1 3)');
    steps.push('│  │  │  │  │     ...');
    steps.push('│  │  │  │  └─ ...');
    steps.push('│  │  │  └─ (cc -14 4) → 0');
    steps.push('│  │  └─ ...');
    steps.push('│  └─ (cc -39 5) → 0');
    steps.push('└─ ...');
    steps.push('');
    steps.push('The tree has many branches. Key observations:');
    steps.push('1. Depth is linear in amount (max depth ≈ amount when using 1-cent coins)');
    steps.push('2. Breadth grows combinatorially');
    steps.push('3. Many branches terminate early due to negative amounts');
    
    return steps;
};

// Analyze time and space complexity
export const analyzeComplexity = (): void => {
    console.log('--- Complexity Analysis ---\n');
    
    console.log('Time Complexity:');
    console.log('Let n = amount, k = number of coin types (5 in our case)');
    console.log('');
    console.log('For 1 coin type (1¢):');
    console.log('  Only way is n 1¢ coins, so cc(n, 1) = 1');
    console.log('  Time: O(n) - linear recursion depth');
    console.log('');
    console.log('For 2 coin types {1¢, 5¢}:');
    console.log('  We can use 0 to floor(n/5) 5¢ coins, rest in 1¢');
    console.log('  Recurrence: T(n,2) = T(n,1) + T(n-5,2)');
    console.log('  This gives T(n,2) = O(n²)');
    console.log('');
    console.log('For 3 coin types {1¢, 5¢, 10¢}:');
    console.log('  T(n,3) = T(n,2) + T(n-10,3)');
    console.log('  This gives T(n,3) = O(n³)');
    console.log('');
    console.log('Generalizing for k coin types:');
    console.log('  T(n,k) = O(n^k)');
    console.log('  For k=5: T(n,5) = O(n⁵)');
    
    console.log('\nSpace Complexity:');
    console.log('The recursion depth is determined by the maximum number of');
    console.log('nested calls. In the worst case:');
    console.log('  - We keep reducing amount by 1¢ until we reach 0');
    console.log('  - This gives depth = n');
    console.log('  - Space complexity: O(n)');
    
    console.log('\nEmpirical growth (calls for different amounts):');
    const testAmounts = [11, 22, 33, 44, 55];
    for (const amount of testAmounts) {
        const { ways, calls } = countChangeWithStats(amount);
        const ratio = calls / Math.pow(amount, 5);
        console.log(`  amount=${amount}: ${calls} calls, ${ways} ways, calls/n⁵≈${ratio.toFixed(6)}`);
    }
    
    console.log('\nNote: The O(n⁵) bound is loose. Actual growth depends on the');
    console.log('specific denominations. For US coins, the growth is polynomial');
    console.log('but with a lower effective exponent due to early termination');
    console.log('of negative-amount branches.');
};

export const answerExercise = (): string => {
    return `Answer to Exercise 1.14:

Orders of growth for the count-change procedure:

Time complexity: O(n⁵) where n is the amount
  - For k coin denominations, the time complexity is O(nᵏ)
  - With 5 coin types (50¢, 25¢, 10¢, 5¢, 1¢), this is O(n⁵)
  - The recurrence is: T(n,k) = T(n,k-1) + T(n-dₖ,k)
  - This leads to polynomial growth with exponent equal to number of coin types

Space complexity: O(n)
  - The maximum recursion depth occurs when we use only 1¢ coins
  - This requires n recursive calls to reduce amount to 0
  - Each call uses constant space (excluding the recursion stack)
  - Therefore, space grows linearly with the amount

Why these orders of growth:
1. The algorithm explores all combinations of coins that sum to the amount
2. For each coin type, we branch: use it or don't use it
3. With 5 coin types, we have a 5-dimensional search space
4. The recursion depth is limited by reducing the amount by at least 1 each time

The tree for 11 cents shows this branching structure clearly, with
exponential growth in the number of leaves but linear growth in depth.`;
};

export const testExercise1_14 = (): void => {
    console.log('Exercise 1.14: Complexity analysis of count-change\n');
    
    console.log('First, let\'s verify count-change works:');
    console.log(`count-change(11) = ${countChange(11)}`);
    console.log(`count-change(100) = ${countChange(100)}`);
    
    console.log('\n' + generateTreeFor11().join('\n'));
    analyzeComplexity();
    
    console.log('\n' + answerExercise());
};

// Uncomment to run the test:
// testExercise1_14();