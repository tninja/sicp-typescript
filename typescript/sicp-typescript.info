This is sicp-typescript.info, produced by conversion from sicp.info to TypeScript version, by opencode with default model

INFO-DIR-SECTION TypeScript Implementation of SICP
START-INFO-DIR-ENTRY
* SICP-TypeScript: (sicp-typescript). Structure and Interpretation of Computer Programs - TypeScript Edition
END-INFO-DIR-ENTRY


File: sicp-typescript.info,  Node: Top,  Next: UTF,  Prev: (dir),  Up: (dir)

Structure and Interpretation of Computer Programs - TypeScript Edition
====================================================================

Second Edition
by Harold Abelson and Gerald Jay Sussman, with Julie Sussman
foreword by Alan J. Perlis
(C) 1996 Massachusetts Institute of Technology

TypeScript Implementation Conversion

* Menu:

* UTF::              TypeScript Version Introduction
* Dedication::       Dedication
* Foreword::         Foreword
* Preface::          Preface to the Second Edition
* Preface 1e::       Preface to the First Edition
* Acknowledgements:: Acknowledgements
* Chapter 1::        Building Abstractions with Procedures
* Chapter 2::        Building Abstractions with Data
* Chapter 3::        Modularity, Objects, and State
* Chapter 4::        Metalinguistic Abstraction
* Chapter 5::        Computing with Register Machines
* References::       References
* Index::            Index

 --- The Detailed Node Listing ---

Programming in TypeScript

* 1-1::              The Elements of Programming
* 1-2::              Procedures and the Processes They Generate
* 1-3::              Formulating Abstractions with Higher-Order Procedures

The Elements of Programming

* 1-1-1::            Expressions
* 1-1-2::            Naming and the Environment
* 1-1-3::            Evaluating Combinations
* 1-1-4::            Compound Procedures
* 1-1-5::            The Substitution Model for Procedure Application
* 1-1-6::            Conditional Expressions and Predicates
* 1-1-7::            Example: Square Roots by Newton's Method
* 1-1-8::            Procedures as Black-Box Abstractions

Procedures and the Processes They Generate

* 1-2-1::            Linear Recursion and Iteration
* 1-2-2::            Tree Recursion
* 1-2-3::            Orders of Growth
* 1-2-4::            Exponentiation
* 1-2-5::            Greatest Common Divisors
* 1-2-6::            Example: Testing for Primality

Formulating Abstractions with Higher-Order Procedures

* 1-3-1::            Procedures as Arguments
* 1-3-2::            Constructing Procedures Using Lambda Expressions
* 1-3-3::            Procedures as General Methods
* 1-3-4::            Procedures as Returned Values

Building Abstractions with Data

* 2-1::              Introduction to Data Abstraction
* 2-2::              Hierarchical Data and the Closure Property
* 2-3::              Symbolic Data
* 2-4::              Multiple Representations for Abstract Data
* 2-5::              Systems with Generic Operations

Introduction to Data Abstraction

* 2-1-1::            Example: Arithmetic Operations for Rational Numbers
* 2-1-2::            Abstraction Barriers
* 2-1-3::            What Is Meant by Data?
* 2-1-4::            Extended Exercise: Interval Arithmetic

Hierarchical Data and the Closure Property

* 2-2-1::            Representing Sequences
* 2-2-2::            Hierarchical Structures
* 2-2-3::            Sequences as Conventional Interfaces
* 2-2-4::            Example: A Picture Language

Symbolic Data

* 2-3-1::            Quotation
* 2-3-2::            Example: Symbolic Differentiation
* 2-3-3::            Example: Representing Sets
* 2-3-4::            Example: Huffman Encoding Trees

Multiple Representations for Abstract Data

* 2-4-1::            Representations for Complex Numbers
* 2-4-2::            Tagged data
* 2-4-3::            Data-Directed Programming and Additivity

Systems with Generic Operations

* 2-5-1::            Generic Arithmetic Operations
* 2-5-2::            Combining Data of Different Types
* 2-5-3::            Example: Symbolic Algebra

Modularity, Objects, and State

* 3-1::              Assignment and Local State
* 3-2::              The Environment Model of Evaluation
* 3-3::              Modeling with Mutable Data
* 3-4::              Concurrency: Time Is of the Essence
* 3-5::              Streams

Assignment and Local State

* 3-1-1::            Local State Variables
* 3-1-2::            The Benefits of Introducing Assignment
* 3-1-3::            The Costs of Introducing Assignment

The Environment Model of Evaluation

* 3-2-1::            The Rules for Evaluation
* 3-2-2::            Applying Simple Procedures
* 3-2-3::            Frames as the Repository of Local State
* 3-2-4::            Internal Definitions

Modeling with Mutable Data

* 3-3-1::            Mutable List Structure
* 3-3-2::            Representing Queues
* 3-3-3::            Representing Tables
* 3-3-4::            A Simulator for Digital Circuits
* 3-3-5::            Propagation of Constraints

Concurrency: Time Is of the Essence

* 3-4-1::            The Nature of Time in Concurrent Systems
* 3-4-2::            Mechanisms for Controlling Concurrency

Streams

* 3-5-1::            Streams Are Delayed Lists
* 3-5-2::            Infinite Streams
* 3-5-3::            Exploiting the Stream Paradigm
* 3-5-4::            Streams and Delayed Evaluation
* 3-5-5::            Modularity of Functional Programs and Modularity of
                      Objects

Metalinguistic Abstraction

* 4-1::              The Metacircular Evaluator
* 4-2::              Variations on a TypeScript -- Lazy Evaluation
* 4-3::              Variations on a TypeScript -- Nondeterministic Computing
* 4-4::              Logic Programming

The Metacircular Evaluator

* 4-1-1::            The Core of the Evaluator
* 4-1-2::            Representing Expressions
* 4-1-3::            Evaluator Data Structures
* 4-1-4::            Running the Evaluator as a Program
* 4-1-5::            Data as Programs
* 4-1-6::            Internal Definitions
* 4-1-7::            Separating Syntactic Analysis from Execution

Variations on a TypeScript -- Lazy Evaluation

* 4-2-1::            Normal Order and Applicative Order
* 4-2-2::            An Interpreter with Lazy Evaluation
* 4-2-3::            Streams as Lazy Lists

Variations on a TypeScript -- Nondeterministic Computing

* 4-3-1::            Amb and Search
* 4-3-2::            Examples of Nondeterministic Programs
* 4-3-3::            Implementing the Amb Evaluator

Logic Programming

* 4-4-1::            Deductive Information Retrieval
* 4-4-2::            How the Query System Works
* 4-4-3::            Is Logic Programming Mathematical Logic?
* 4-4-4::            Implementing the Query System

Implementing the Query System

* 4-4-4-1::          The Driver Loop and Instantiation
* 4-4-4-2::          The Evaluator
* 4-4-4-3::          Finding Assertions by Pattern Matching
* 4-4-4-4::          Rules and Unification
* 4-4-4-5::          Maintaining the Data Base
* 4-4-4-6::          Stream Operations
* 4-4-4-7::          Query Syntax Procedures
* 4-4-4-8::          Frames and Bindings

Computing with Register Machines

* 5-1::              Designing Register Machines
* 5-2::              A Register-Machine Simulator
* 5-3::              Storage Allocation and Garbage Collection
* 5-4::              The Explicit-Control Evaluator
* 5-5::              Compilation

Designing Register Machines

* 5-1-1::            A Language for Describing Register Machines
* 5-1-2::            Abstraction in Machine Design
* 5-1-3::            Subroutines
* 5-1-4::            Using a Stack to Implement Recursion
* 5-1-5::            Instruction Summary

A Register-Machine Simulator

* 5-2-1::            The Machine Model
* 5-2-2::            The Assembler
* 5-2-3::            Generating Execution Procedures for Instructions
* 5-2-4::            Monitoring Machine Performance

Storage Allocation and Garbage Collection

* 5-3-1::            Memory as Vectors
* 5-3-2::            Maintaining the Illusion of Infinite Memory

Registers and operations

* 5-4-1::            The Core of the Explicit-Control Evaluator
* 5-4-2::            Sequence Evaluation and Tail Recursion
* 5-4-3::            Conditionals, Assignments, and Definitions
* 5-4-4::            Running the Evaluator

An overview of the compiler

* 5-5-1::            Structure of the Compiler
* 5-5-2::            Compiling Expressions
* 5-5-3::            Compiling Combinations
* 5-5-4::            Combining Instruction Sequences
* 5-5-5::            An Example of Compiled Code
* 5-5-6::            Lexical Addressing
* 5-5-7::            Interfacing Compiled Code to the Evaluator


File: sicp-typescript.info,  Node: UTF,  Next: Dedication,  Prev: Top,  Up: Top

TypeScript Version Introduction
*****************************

This is the TypeScript edition of SICP, converted from the original Scheme version to demonstrate the same computer science concepts using modern TypeScript programming language.

    You are probably reading it in an Info hypertext browser, such as
the Info mode of Emacs.  You might alternatively be reading it
TeX-formatted on your screen or printer, though that would be silly.
And, if printed, expensive.

    The TypeScript implementation provides the same algorithms and concepts as the original Scheme version, but adapted to TypeScript's syntax and type system. TypeScript was chosen because it provides:

    - Static typing with type inference
    - First-class functions and closures  
    - Modern object-oriented programming features
    - Excellent tooling and IDE support
    - Compatibility with JavaScript ecosystem

    The conversion maintains the pedagogical value of the original while making it accessible to programmers who prefer statically-typed languages. All examples are runnable TypeScript code that demonstrates the fundamental concepts of:

    - Procedural abstraction
    - Data abstraction  
    - Modularity and state
    - Metalinguistic abstraction
    - Register machines and compilation

    If you modify examples to improve the TypeScript implementation or add new exercises, please update the version information and share your contributions with the community.

The TypeScript conversion was created to help bridge the gap between functional programming concepts taught in SICP and the practical world of modern software development with TypeScript.


File: sicp-typescript.info,  Node: Dedication,  Next: Foreword,  Prev: UTF,  Up: Top

Dedication
**********

This book is dedicated, in respect and admiration, to the spirit that
lives in the computer.

     "I think that it's extraordinarily important that we in computer
     science keep fun in computing.  When it started out, it was an
     awful lot of fun.  Of course, the paying customers got shafted
     every now and then, and after a while we began to take their
     complaints seriously. We began to feel as if we really were
     responsible for the successful, error-free perfect use of these
     machines. I don't think we are. I think we're responsible for
     stretching them, setting them off in new directions, and keeping
     fun in the house. I hope the field of computer science never
     loses its sense of fun. Above all, I hope we don't become
     missionaries. Don't feel as if you're Bible salesmen. The world
     has too many of those already. What you know about computing
     other people will learn. Don't feel as if the key to successful
     computing is only in your hands. What's in your hands, I think
     and hope, is intelligence: the ability to see the machine as more
     than when you were first led up to it, that you can make it more."

     --Alan J. Perlis (April 1, 1922  February 7, 1990)


File: sicp-typescript.info,  Node: Foreword,  Next: Preface,  Prev: Dedication,  Up: Top

Foreword
********

Educators, generals, dieticians, psychologists, and parents program.
Armies, students, and some societies are programmed.  An assault on
large problems employs a succession of programs, most of which spring
into existence en route.  These programs are rife with issues that
appear to be particular to the problem at hand.  To appreciate
programming as an intellectual activity in its own right you must turn
to computer programming; you must read and write computer
programs--many of them.  It doesn't matter much what the programs are
about or what applications they serve.  What does matter is how well
they perform and how smoothly they fit with other programs in the
creation of still greater programs.  The programmer must seek both
perfection of part and adequacy of collection.  In this book the use of
"program" is focused on the creation, execution, and study of programs
written in a dialect of TypeScript for execution on a digital computer.
Using TypeScript we restrict or limit not what we may program, but only the
notation for our program descriptions.

   Our traffic with the subject matter of this book involves us with
three foci of phenomena: the human mind, collections of computer
programs, and the computer.  Every computer program is a model, hatched
in the mind, of a real or mental process.  These processes, arising
from human experience and thought, are huge in number, intricate in
detail, and at any time only partially understood.  They are modeled to
our permanent satisfaction rarely by our computer programs.  Thus even
though our programs are carefully handcrafted discrete collections of
symbols, mosaics of interlocking functions, they continually evolve: we
change them as our perception of the model deepens, enlarges,
generalizes until the model ultimately attains a metastable place
within still another model with which we struggle.  The source of the
exhilaration associated with computer programming is the continual
unfolding within the mind and on the computer of mechanisms expressed
as programs and the explosion of perception they generate.  If art
interprets our dreams, the computer executes them in the guise of
programs!

   For all its power, the computer is a harsh taskmaster.  Its programs
must be correct, and what we wish to say must be said accurately in
every detail.  As in every other symbolic activity, we become convinced
of program truth through argument.  TypeScript itself can be assigned a
semantics (another model, by the way), and if a program's function can
be specified, say, in the predicate calculus, the proof methods of
logic can be used to make an acceptable correctness argument.
Unfortunately, as programs get large and complicated, as they almost
always do, the adequacy, consistency, and correctness of the
specifications themselves become open to doubt, so that complete formal
arguments of correctness seldom accompany large programs.  Since large
programs grow from small ones, it is crucial that we develop an arsenal
of standard program structures of whose correctness we have become
sure--we call them idioms--and learn to combine them into larger
structures using organizational techniques of proven value.  These
techniques are treated at length in this book, and understanding them
is essential to participation in the Promethean enterprise called
programming.  More than anything else, the uncovering and mastery of
powerful organizational techniques accelerates our ability to create
large, significant programs.  Conversely, since writing large programs
is very taxing, we are stimulated to invent new methods of reducing the
mass of function and detail to be fitted into large programs.

   Unlike programs, computers must obey the laws of physics.  If they
wish to perform rapidly--a few nanoseconds per state change--they must
transmit electrons only small distances (at most 11 over 2 feet).  The
heat generated by the huge number of devices so concentrated in space
has to be removed.  An exquisite engineering art has been developed
balancing between multiplicity of function and density of devices.  In
any event, hardware always operates at a level more primitive than that
at which we care to program.  The processes that transform our TypeScript
programs to "machine" programs are themselves abstract models which we
program.  Their study and creation give a great deal of insight into
organizational programs associated with programming arbitrary
models.  Of course the computer itself can be so modeled.  Think of it:
the behavior of the smallest physical switching element is modeled by
quantum mechanics described by differential equations whose detailed
behavior is captured by numerical approximations represented in
computer programs executing on computers composed of ...!

   It is not merely a matter of tactical convenience to separately
identify the three foci.  Even though, as they say, it's all in the
head, this logical separation induces an acceleration of symbolic
traffic between these foci whose richness, vitality, and potential is
exceeded in human experience only by the evolution of life itself.  At
best, relationships between the foci are metastable.  The computers are
never large enough or fast enough.  Each breakthrough in hardware
technology leads to more massive programming enterprises, new
organizational principles, and an enrichment of abstract models.  Every
reader should ask himself periodically "Toward what end, toward what
end?"--but do not ask it too often lest you pass up the fun of
programming for the constipation of bittersweet philosophy.

   Among the programs we write, some (but never enough) perform a
precise mathematical function such as sorting or finding the maximum of
a sequence of numbers, determining primality, or finding the square
root.  We call such programs algorithms, and a great deal is known of
their optimal behavior, particularly with respect to the two important
parameters of execution time and data storage requirements.  A
programmer should acquire good algorithms and idioms.  Even though some
programs resist precise specifications, it is the responsibility of the
programmer to estimate, and always to attempt to improve, their
performance.

   TypeScript is a modern survivor, having evolved from JavaScript and
established itself as a major force in web and enterprise development.
Among the active programming languages, it represents a significant advancement
in bringing static typing and modern features to a widely-used platform.
Both TypeScript and its parent JavaScript have supported the programming needs of
important areas of application, JavaScript for web development and
TypeScript for large-scale enterprise applications.  These two areas
continue to be important, and their programmers are so devoted to these
languages that TypeScript and JavaScript may well continue in active use for
decades to come.

   TypeScript evolves.  The TypeScript language used in this text has built upon
the foundation of JavaScript and differs from the latter in several important
ways, including static typing for variable binding and permitting
functions to be first-class citizens with strong type safety.  In its semantic structure
TypeScript is as closely akin to modern functional languages as to object-oriented
languages.  It would be difficult to find two languages that are the
communicating coin of two more different cultures than those gathered
around dynamic and static typing.  Languages like Python are for building scripts--flexible,
breathtaking, dynamic structures built by rapid prototyping.
TypeScript is for building robust systems--imposing,
breathtaking, type-safe structures built by teams assembling
well-defined components into place.  The organizing principles used are the
same in both cases, except for one extraordinarily important
difference: The type safety and tooling support entrusted to the
individual TypeScript programmer is more than an order of magnitude greater
than that to be found within dynamically-typed enterprises.  TypeScript programs
benefit from comprehensive IDE support, automated refactoring, and
compile-time error detection.  The type system, TypeScript's native data structure, is largely
responsible for such growth of reliability.  The simple structure and
natural applicability of interfaces are reflected in functions that are
amazingly reusable.  In dynamically-typed languages the plethora of implicit
data structures induces a specialization within functions that inhibits and
penalizes casual cooperation.  It is better to have 100 functions
operate on one well-defined interface than to have 10 functions operate on 10
different data structures.  As a result the script must evolve or the
system must stand unchanged for maintenance.

   To illustrate this difference, compare the treatment of material and
exercises within this book with that in any first-course text using
Python.  Do not labor under the illusion that this is a text digestible
only at universities with engineering programs, peculiar to the breed found there.  It is precisely what a
serious book on programming with static types must be, no matter who the student is
or where it is used.

   Note that this is a text about programming, unlike most TypeScript books,
which are used as a preparation for work in web development.
After all, the critical programming concerns of software engineering
and computer science tend to coalesce as the systems under
investigation become larger.  This explains why there is such growing
interest in TypeScript outside of web development.

   As one would expect from its goals, modern software development
generates many significant programming problems.  In other programming
cultures this spate of problems spawns new languages.  Indeed, in any
very large programming task a useful organizing principle is to control
and isolate traffic within task modules via the invention of
language.  These languages tend to become less primitive as one
approaches the boundaries of the system where we humans interact most
often.  As a result, such systems contain complex language-processing
functions replicated many times.  TypeScript has such a well-defined syntax and
type system that parsing can be treated as an elementary task.  Thus
parsing technology plays almost no role in TypeScript programs, and the
construction of language processors is rarely an impediment to the rate
of growth and change of large TypeScript systems.  Finally, it is this very
clarity of syntax and type safety that is responsible for the burden
and freedom borne by all TypeScript programmers.  No TypeScript program of any size
beyond a few lines can be written without being saturated with
type-safe functions.  Invent and fit; have fits and reinvent!  We
toast the TypeScript programmer who types his thoughts with well-defined interfaces.

Alan J. Perlis
New Haven, Connecticut


File: sicp-typescript.info,  Node: Preface,  Next: Preface 1e,  Prev: Foreword,  Up: Top

Preface to the Second Edition
*****************************

     Is it possible that software is not like anything else, that it is
     meant to be discarded: that the whole point is to always see it as
     a soap bubble?

     --Alan J. Perlis

   The material in this book has been the basis of MIT's entry-level
computer science subject since 1980.  We had been teaching this
material for four years when the first edition was published, and
twelve more years have elapsed until the appearance of this second
edition.  We are pleased that our work has been widely adopted and
incorporated into other texts.  We have seen our students take the
ideas and programs in this book and build them in as the core of new
computer systems and languages.  In literal realization of an ancient
Talmudic pun, our students have become our builders.  We are lucky to
have such capable students and such accomplished builders.

   In preparing this edition, we have incorporated hundreds of
clarifications suggested by our own teaching experience and the
comments of colleagues at MIT and elsewhere.  We have redesigned most
of the major programming systems in the book, including the
generic-arithmetic system, the interpreters, the register-machine
simulator, and the compiler; and we have rewritten all the program
examples to ensure that any TypeScript implementation conforming to the
modern TypeScript standards will be able to run the code.

   This edition emphasizes several new themes.  The most important of
these is the central role played by different approaches to dealing
with time in computational models: objects with state, concurrent
programming, functional programming, lazy evaluation, and
nondeterministic programming.  We have included new sections on
concurrency and nondeterminism, and we have tried to integrate this
theme throughout the book.

   The first edition of the book closely followed the syllabus of our
MIT one-semester subject.  With all the new material in the second
edition, it will not be possible to cover everything in a single
semester, so the instructor will have to pick and choose.  In our own
teaching, we sometimes skip the section on logic programming (section
*Note 4-4::), we have students use the register-machine simulator but
we do not cover its implementation (section *Note 5-2::), and we give
only a cursory overview of the compiler (section *Note 5-5::).  Even
so, this is still an intense course.  Some instructors may wish to
cover only the first three or four chapters, leaving the other material
for subsequent courses.

   The TypeScript implementation and website provides
support for users of this book.  This includes programs from the book,
sample programming assignments, supplementary materials, and
downloadable implementations of the TypeScript examples.


File: sicp-typescript.info,  Node: Preface 1e,  Next: Acknowledgements,  Prev: Preface,  Up: Top

Preface to the First Edition
****************************

     A computer is like a violin.  You can imagine a novice trying
     first a phonograph and then a violin.  The latter, he says, sounds
     terrible.  That is the argument we have heard from our humanists
     and most of our computer scientists.  Computer programs are good,
     they say, for particular purposes, but they aren't flexible.
     Neither is a violin, or a typewriter, until you learn how to use
     it.

     --Marvin Minsky, "Why Programming Is a Good Medium for Expressing
     Poorly-Understood and Sloppily-Formulated Ideas"

   "The Structure and Interpretation of Computer Programs" is the
entry-level subject in computer science at the Massachusetts Institute
of Technology.  It is required of all students at MIT who major in
electrical engineering or in computer science, as one-fourth of the
"common core curriculum," which also includes two subjects on circuits
and linear systems and a subject on the design of digital systems.  We
have been involved in the development of this subject since 1978, and
we have taught this material in its present form since the fall of 1980
to between 600 and 700 students each year.  Most of these students have
had little or no prior formal training in computation, although many
have played with computers a bit and a few have had extensive
programming or hardware-design experience.

   Our design of this introductory computer-science subject reflects
two major concerns.  First, we want to establish the idea that a
computer language is not just a way of getting a computer to perform
operations but rather that it is a novel formal medium for expressing
ideas about methodology.  Thus, programs must be written for people to
read, and only incidentally for machines to execute.  Second, we
believe that the essential material to be addressed by a subject at
this level is not the syntax of particular programming-language
constructs, nor clever algorithms for computing particular functions
efficiently, nor even the mathematical analysis of algorithms and the
foundations of computing, but rather the techniques used to control the
intellectual complexity of large software systems.

   Our goal is that students who complete this subject should have a
good feel for the elements of style and the aesthetics of programming.
They should have command of the major techniques for controlling
complexity in a large system.  They should be capable of reading a
50-page-long program, if it is written in an exemplary style.  They
should know what not to read, and what they need not understand at any
moment.  They should feel secure about modifying a program, retaining
the spirit and style of the original author.

   These skills are by no means unique to computer programming.  The
techniques we teach and draw upon are common to all of engineering
design.  We control complexity by building abstractions that hide
details when appropriate.  We control complexity by establishing
conventional interfaces that enable us to construct systems by
combining standard, well-understood pieces in a "mix and match" way.
We control complexity by establishing new languages for describing a
design, each of which emphasizes particular aspects of the design and
deemphasizes others.

   Underlying our approach to this subject is our conviction that
"computer science" is not a science and that its significance has
little to do with computers.  The computer revolution is a revolution
in the way we think and in the way we express what we think.  The
essence of this change is the emergence of what might best be called "procedural
epistemology"--the study of the structure of knowledge from an
imperative point of view, as opposed to the more declarative point of
view taken by classical mathematical subjects.  Mathematics provides a
framework for dealing precisely with notions of "what is."  Computation
provides a framework for dealing precisely with notions of "how to."

   In teaching our material we use a dialect of the programming
language TypeScript.  We never formally teach the language, because we don't
have to.  We just use it, and students pick it up in a few days.  This
is one great advantage of modern statically-typed languages: They have very clear
ways of forming compound expressions, and well-defined syntax.
All of the formal properties can be covered in an hour, like the rules
of chess.  After a short time we forget about syntactic details of the
language (because there are few) and get on with the real
issues--figuring out what we want to compute, how we will decompose
problems into manageable parts, and how we will work on the parts.
Another advantage of TypeScript is that it supports (but does not enforce)
more of the large-scale strategies for modular decomposition of
programs than any other language we know.  We can make procedural and
data abstractions, we can use higher-order functions to capture common
patterns of usage, we can model local state using assignment and data
mutation, we can link parts of a program with streams and delayed
evaluation, and we can easily implement embedded languages.  All of
this is embedded in an interactive environment with excellent support
for incremental program design, construction, testing, and debugging.
We thank all the generations of language designers, starting with Anders Hejlsberg,
who have fashioned a fine tool of unprecedented power and
elegance.

   TypeScript, the language we use, is an attempt to bring
together the power and safety of static typing with the flexibility of JavaScript.
From JavaScript we take the ubiquity and ecosystem compatibility.
From static typing we take lexical scoping, type inference, and compile-time error checking,
which are gifts from the pioneers of programming-language design who were on the TypeScript committee.
We wish to cite the designers of functional languages for their insights into the
relationship of lambda calculus to the structure of programming languages.
We also recognize our debt to the mathematicians who scouted out this territory decades before computers
appeared on the scene.  These pioneers include Alonzo Church, Barkley Rosser,
Stephen Kleene, and Haskell Curry.


File: sicp-typescript.info,  Node: Acknowledgements,  Next: Chapter 1,  Prev: Preface 1e,  Up: Top

Acknowledgements
****************

We would like to thank the many people who have helped us develop this
book and this curriculum.

   Our subject is a clear intellectual descendant of "6.231," a
wonderful subject on programming linguistics and the lambda calculus
taught at MIT in the late 1960s by Jack Wozencraft and Arthur Evans, Jr.

   We owe a great debt to Robert Fano, who reorganized MIT's
introductory curriculum in electrical engineering and computer science
to emphasize the principles of engineering design.  He led us in
starting out on this enterprise and wrote the first set of subject
notes from which this book evolved.

   Much of the style and aesthetics of programming that we try to teach
were developed in conjunction with Guy Lewis Steele Jr., who
collaborated with Gerald Jay Sussman in the initial development of the
Scheme language.  In addition, David Turner, Peter Henderson, Dan
Friedman, David Wise, and Will Clinger have taught us many of the
techniques of the functional programming community that appear in this
book.

   Joel Moses taught us about structuring large systems.  His
experience with the Macsyma system for symbolic computation provided
insight that one should avoid complexities of control and
concentrate on organizing the data to reflect the real structure of the
world being modeled.

   Marvin Minsky and Seymour Papert formed many of our attitudes about
programming and its place in our intellectual lives.  To them we owe
the understanding that computation provides a means of expression for
exploring ideas that would otherwise be too complex to deal with
precisely.  They emphasize that a student's ability to write and modify
programs provides a powerful medium in which exploring becomes a
natural activity.

   We also strongly agree with Alan Perlis that programming is lots of
fun and we had better be careful to support the joy of programming.
Part of this joy derives from observing great masters at work.  We are
fortunate to have been apprentice programmers at the feet of Bill
Gosper and Richard Greenblatt.

   It is difficult to identify all the people who have contributed to
the development of our curriculum.  We thank all the lecturers,
recitation instructors, and tutors who have worked with us over the
past fifteen years and put in many extra hours on our subject,
especially Bill Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis
Braida, Eric Grimson, Rod Brooks, Lynn Stein, and Peter Szolovits.  We
would like to specially acknowledge the outstanding teaching
contributions of Franklyn Turbak, now at Wellesley; his work in
undergraduate instruction set a standard that we can all aspire to.  We
are grateful to Jerry Saltzer and Jim Miller for helping us grapple
with the mysteries of concurrency, and to Peter Szolovits and David
McAllester for their contributions to the exposition of
nondeterministic evaluation in *Note Chapter 4::.

   Many people have put in significant effort presenting this material
at other universities.  Some of the people we have worked closely with
are Jacob Katzenelson at the Technion, Hardy Mayer at the University of
California at Irvine, Joe Stoy at Oxford, Elisha Sacks at Purdue, and
Jan Komorowski at the Norwegian University of Science and Technology.
We are exceptionally proud of our colleagues who have received major
teaching awards for their adaptations of this subject at other
universities, including Kenneth Yip at Yale, Brian Harvey at the
University of California at Berkeley, and Dan Huttenlocher at Cornell.

   Al Moye' arranged for us to teach this material to engineers at
Hewlett-Packard, and for the production of videotapes of these
lectures.  We would like to thank the talented instructors--in
particular Jim Miller, Bill Siebert, and Mike Eisenberg--who have
designed continuing education courses incorporating these tapes and
taught them at universities and industry all over the world.

   Many educators in other countries have put in significant work
translating the first edition.  Michel Briand, Pierre Chamard, and
Andre' Pic produced a French edition; Susanne Daniels-Herold produced a
German edition; and Fumio Motoyoshi produced a Japanese edition.  We do
not know who produced the Chinese edition, but we consider it an honor
to have been selected as the subject of an "unauthorized" translation.

   It is hard to enumerate all the people who have made technical
contributions to the development of the TypeScript systems we use for
instructional purposes.  In addition to Anders Hejlsberg, principal designers
have included Luke Hoban, Daniel Rosenwasser, James Henry, and
others from the TypeScript team.  Others who have put in significant time are the countless
contributors to the JavaScript ecosystem, TypeScript compiler team, and
community members who have helped build the tools we rely on.

   Beyond the MIT implementation, we would like to thank the many people
who worked on the TypeScript language standard, including Anders Hejlsberg
and the TypeScript team at Microsoft, who continue to develop this
powerful language.

   The broader TypeScript community has been instrumental in developing
the language and its ecosystem.  This work goes beyond issues of language design to
encompass significant educational innovations, such as comprehensive documentation,
excellent tooling support, and wonderful books
by the TypeScript team and community contributors.

   We appreciate the work of those who contributed to making this a
real book, especially the editors and technical reviewers who helped
ensure accuracy and clarity of the TypeScript conversion.

   Finally, we would like to acknowledge the support of the
organizations that have encouraged this work over the years, including
support from Microsoft, made possible by Anders Hejlsberg and the TypeScript team,
and support from the open-source community, made possible by countless contributors worldwide.


File: sicp-typescript.info,  Node: Chapter 1,  Next: Chapter 2,  Prev: Acknowledgements,  Up: Top

1 Building Abstractions with Procedures
***************************************

     The acts of the mind, wherein it exerts its power over simple
     ideas, are chiefly these three: 1. Combining several simple ideas
     into one compound one, and thus all complex ideas are made. 2.
     The second is bringing two ideas, whether simple or complex,
     together, and setting them by one another so as to take a view of
     them at once, without uniting them into one, by which it gets all
     its ideas of relations. 3.  The third is separating them from all
     other ideas that accompany them in their real existence: this is
     called abstraction, and thus all its general ideas are made.

     --John Locke, _An Essay Concerning Human Understanding_ (1690)

   We are about to study the idea of a "computational process".
Computational processes are abstract beings that inhabit computers.  As
they evolve, processes manipulate other abstract things called "data".
The evolution of a process is directed by a pattern of rules called a "program".
People create programs to direct processes.  In effect, we conjure the
spirits of the computer with our spells.

   A computational process is indeed much like a sorcerer's idea of a
spirit.  It cannot be seen or touched.  It is not composed of matter at
all.  However, it is very real.  It can perform intellectual work.  It
can answer questions.  It can affect the world by disbursing money at a
bank or by controlling a robot arm in a factory.  The programs we use
to conjure processes are like a sorcerer's spells.  They are carefully
composed from symbolic expressions in arcane and esoteric "programming
languages" that prescribe the tasks we want our processes to perform.

   A computational process, in a correctly working computer, executes
programs precisely and accurately.  Thus, like the sorcerer's
apprentice, novice programmers must learn to understand and to
anticipate the consequences of their conjuring.  Even small errors
(usually called "bugs" or "glitches") in programs can have complex and
unanticipated consequences.

   Fortunately, learning to program is considerably less dangerous than
learning sorcery, because the spirits we deal with are conveniently
contained in a secure way.  Real-world programming, however, requires
care, expertise, and wisdom.  A small bug in a computer-aided design
program, for example, can lead to the catastrophic collapse of an
airplane or a dam or the self-destruction of an industrial robot.

   Master software engineers have the ability to organize programs so
that they can be reasonably sure that the resulting processes will
perform the tasks intended.  They can visualize the behavior of their
systems in advance.  They know how to structure programs so that
unanticipated problems do not lead to catastrophic consequences, and when
problems do arise, they can "debug" their programs.  Well-designed
computational systems, like well-designed automobiles or nuclear
reactors, are designed in a modular manner, so that the parts can be
constructed, replaced, and debugged separately.

Programming in TypeScript
.......................

We need an appropriate language for describing processes, and we will
use for this purpose the programming language TypeScript.  Just as our
everyday thoughts are usually expressed in our natural language (such
as English, French, or Japanese), and descriptions of quantitative
phenomena are expressed with mathematical notations, our procedural
thoughts will be expressed in TypeScript.  TypeScript was created in the
2010s as a typed superset of JavaScript, bringing static typing and
modern language features to the widely-used JavaScript ecosystem.

   Despite its inception as a typed JavaScript, TypeScript is a
practical programming language.  A TypeScript "runtime" is a machine that
carries out processes described in the TypeScript language.  The first TypeScript
compiler was implemented by Anders Hejlsberg with the help of colleagues and
students in the TypeScript team at Microsoft.(1)  TypeScript,
whose name reflects its relationship to JavaScript, was designed to provide
type safety and tooling support for attacking programming problems
such as the development of large-scale web applications and enterprise
software.  It included for this purpose new data objects known as
interfaces and types, which most strikingly set it apart from all other
languages of the period.

   TypeScript was not the product of a concerted design effort.  Instead,
it evolved informally in an experimental manner in response to users'
needs and to pragmatic implementation considerations.  TypeScript's informal
evolution has continued through the years, and the community of TypeScript
users has traditionally embraced the official standardization and improvement
efforts led by Microsoft.  This evolution, together with the
flexibility and elegance of the initial conception, has enabled TypeScript,
which is one of the most rapidly adopted languages in widespread use today, to
continually adapt to encompass the most modern
ideas about program design.  Thus, TypeScript is by now a family of
compatible versions, which, while sharing most of the original features, may differ from one
another in significant ways.  The version of TypeScript used in this book is
the modern standard TypeScript with full type support.(2)

   Because of its experimental character and its emphasis on type
safety, TypeScript was at first very different from dynamically-typed
languages, at least in comparison with JavaScript.  Over the years,
however, TypeScript compilers have been developed that translate programs
into JavaScript that can perform efficiently in both browsers and on servers.
And for special applications, TypeScript has been used with
great effectiveness.(3)  Although TypeScript has not yet overcome its old
reputation as being just "typed JavaScript," TypeScript is now used in many
applications where type safety and maintainability are essential concerns.  For example,
TypeScript has become a language of choice for enterprise applications and for
development of large-scale web applications and for extension languages for frameworks.

   If TypeScript is not a purely functional language, why are we using it as
framework for our discussion of programming?  Because the language
possesses unique features that make it an excellent medium for studying
important programming constructs and data structures and for relating
them to the linguistic features that support them.  The most
significant of these features is the fact that TypeScript descriptions of
processes, called "functions," can themselves be represented and
manipulated as TypeScript data (as first-class citizens).  The importance of this is that there are
powerful program-design techniques that rely on the ability to blur the
traditional distinction between "passive" data and "active" processes.
As we shall discover, TypeScript's flexibility in handling functions as data
makes it one of the most convenient languages in existence for
exploring these techniques.  The ability to represent functions as
data also makes TypeScript an excellent language for writing programs that
must manipulate other programs as data, such as the interpreters and
compilers that support computer languages.  Above and beyond these
considerations, programming in TypeScript is great fun.

* Menu:

* 1-1::              The Elements of Programming
* 1-2::              Procedures and the Processes They Generate
* 1-3::              Formulating Abstractions with Higher-Order Procedures

   ---------- Footnotes ----------

   (1) The `TypeScript Handbook' appeared in 2012, and the `TypeScript
2.0 Specification' (Hejlsberg 2014) was published in 2014.  The
early history of TypeScript is described in the official TypeScript documentation.

   (2) The two major JavaScript/TypeScript variants in which most major
applications of 2010s were written are JavaScript (ECMAScript) and TypeScript.
JavaScript spawned a number of supersets and transpiled languages, such as
CoffeeScript and Flow, which provided various degrees of typing and syntax improvements.
The TypeScript dialect used in this book, called TypeScript (Hejlsberg 2012), was invented in 2012 by
Anders Hejlsberg and his team at Microsoft and later adopted as the
standard for type-safe JavaScript development.  TypeScript became an official standard in 2014.

   (3) One such special application was a breakthrough computation of
business importance--the development of modern web applications
that extended previous results by orders of magnitude, and
demonstrated that the development of large-scale maintainable software is possible with
strong typing and excellent tooling.  This
computation was made possible by new development methodologies, a
powerful compiler, and excellent tooling all
implemented with aid of software tools written in TypeScript (Microsoft TypeScript Team 2014+).


File: sicp-typescript.info,  Node: 1-1,  Next: 1-2,  Prev: Chapter 1,  Up: Chapter 1

1.1 The Elements of Programming
===============================

A powerful programming language is more than just a means for
instructing a computer to perform tasks.  The language also serves as a
framework within which we organize our ideas about processes.  Thus,
when we describe a language, we should pay particular attention to the
means that the language provides for combining simple ideas to form
more complex ideas.  Every powerful language has three mechanisms for
accomplishing this:

"primitive expressions"
     which represent the simplest entities the language is concerned
     with,

"means of combination"
     by which compound elements are built from simpler ones, and

"means of abstraction"
     by which compound elements can be named and manipulated as units.


   In programming, we deal with two kinds of elements: functions and
data. (Later we will discover that they are really not so distinct.)
Informally, data is "stuff" that we want to manipulate, and functions
are descriptions of the rules for manipulating the data.  Thus, any
powerful programming language should be able to describe primitive data
and primitive functions and should have methods for combining and
abstracting functions and data.

In this chapter we will deal only with simple numerical data so that
we can focus on the rules for building functions.(1)  In later chapters
we will see that these same rules allow us to build functions to
manipulate compound data as well.

* Menu:

* 1-1-1::            Expressions
* 1-1-2::            Naming and the Environment
* 1-1-3::            Evaluating Combinations
* 1-1-4::            Compound Functions
* 1-1-5::            The Substitution Model for Function Application
* 1-1-6::            Conditional Expressions and Predicates
* 1-1-7::            Example: Square Roots by Newton's Method
* 1-1-8::            Functions as Black-Box Abstractions

   ---------- Footnotes ----------

   (1) The characterization of numbers as "simple data" is a barefaced
bluff.  In fact, the treatment of numbers is one of the trickiest and
most confusing aspects of any programming language.  Some typical
issues involved are these: Some computer systems distinguish "integers",
such as 2, from "floating-point numbers", such as 2.71.  Is the floating-point number 2.00
different from the integer 2?  Are the arithmetic operations used for
integers the same as the operations used for floating-point numbers?  Does 6
divided by 2 produce 3, or 3.0?  How large a number can we represent?
How many decimal places of accuracy can we represent?  Is the range of
integers the same as the range of floating-point numbers?  Above and beyond these
questions, of course, lies a collection of issues concerning roundoff
and truncation errors - the entire science of numerical analysis.
Since our focus in this book is on large-scale program design rather
than on numerical techniques, we are going to ignore these problems.
The numerical examples in this chapter will exhibit the usual roundoff
behavior that one observes when using arithmetic operations that
preserve a limited number of decimal places of accuracy in non-integer
operations.


File: sicp-typescript.info,  Node: 1-1-1,  Next: 1-1-2,  Prev: 1-1,  Up: 1-1

1.1.1 Expressions
-------------

One easy way to get started at programming is to examine some typical
interactions with a TypeScript environment. Imagine that you are sitting at a
computer terminal or using an IDE.  You type an "expression",
and the environment responds by displaying the result of its "evaluating"
that expression.

   One kind of primitive expression you might type is a number.  (More
precisely, the expression that you type consists of numerals that
represent a number in base 10.)  If you present TypeScript with a number

      486

the environment will respond by printing (1)

      486

   Expressions representing numbers may be combined with an expression
representing a primitive function (such as `+' or `*') to form a
compound expression that represents the application of the function to
those numbers.  For example:

      137 + 349
      486

      1000 - 334
      666

      5 * 99
      495

      10 / 5
      2

      2.7 + 10
      12.7

   Expressions such as these, formed by infix notation in TypeScript,
represent the application of the function specified by the operator to the
arguments that are the values of the operands.  In TypeScript, we use
standard mathematical notation for most operations.

   The convention of placing the operator between operands is known as "infix notation", and it may be familiar from
mathematics.  Infix notation has several advantages, particularly for
readability in mathematical expressions.  However, prefix notation (which we'll see
later with functions) provides other advantages.

   A second feature of TypeScript notation is that it allows combinations to be nested,
that is, to have combinations whose elements are themselves combinations:

      (3 * 5) + (10 - 6)
      19

   There is no limit (in principle) to the depth of such nesting and to
the overall complexity of expressions that the TypeScript environment can
evaluate.  Modern IDEs and TypeScript compilers can handle even very complex
expressions.  Humans, however, may find deeply nested expressions confusing:

      (3 * ((2 * 4) + (3 + 5))) + ((10 - 7) + 6)

   We can help ourselves by writing such an expression in a well-formatted way:

      (3 * 
        ((2 * 4) + 
           (3 + 5))) 
         + 
        ((10 - 7) + 
           6))

   following a formatting convention known as "pretty-printing", in which
each long expression is written so that the operations are aligned
vertically.  The resulting indentations display clearly the structure
of the expression.(2)

   Even with complex expressions, the environment always operates in
the same basic cycle: It reads an expression from the source,
compiles the expression, and prints the result.  This mode of
operation is often expressed by saying that the environment runs in a "compile-execute-print"
cycle. Observe in particular that it is not necessary to explicitly
instruct the environment to print the value of an expression in interpreted
environments.(3)

   ---------- Footnotes ----------

   (1) Throughout this book, when we wish to emphasize the distinction
between the input typed by the user and the response printed by the
environment, we will show the latter in italics.

   (2) Modern TypeScript IDEs typically provide features to aid the user in
formatting expressions.  Two especially useful features are one that
automatically indents to the proper pretty-print position whenever a
new line is started and one that highlights matching parentheses
when they are typed.

   (3) TypeScript obeys the convention that every expression has a value.
This convention, together with the efficiency of modern compilers, is a source
of the observation that "TypeScript programmers know the value of
everything and the cost of optimization."


File: sicp-typescript.info,  Node: 1-1-2,  Next: 1-1-3,  Prev: 1-1-1,  Up: 1-1

1.1.2 Naming and the Environment
-------------------------------

A critical aspect of a programming language is the means it provides
for using names to refer to computational objects.  We say that the
name identifies a "variable" whose "value" is the object.

   In TypeScript, we name things using variable declarations with type annotations.  Typing

      const size: number = 2;

causes the compiler to associate the value 2 with the name
`size'.(1)  Once the name `size' has been associated with the number 2,
we can refer to the value 2 by name:

      size
      2

      5 * size
      10

   Here are further examples of the use of variable declarations:

      const pi: number = 3.14159;

      const radius: number = 10;

      pi * radius * radius
      314.159

      const circumference: number = 2 * pi * radius;

      circumference
      62.8318

   `Const' declarations are our language's simplest means of abstraction, for it
allows us to use simple names to refer to the results of compound
operations, such as the `circumference' computed above.  In general,
computational objects may have very complex structures, and it would be
extremely inconvenient to have to remember and repeat their details
each time we want to use them.  Indeed, complex programs are
constructed by building, step by step, computational objects of
increasing complexity.  The TypeScript compiler makes this step-by-step program
construction particularly convenient because name-object associations
can be created incrementally in successive code blocks.  This feature
encourages incremental development and testing of programs and is
largely responsible for the fact that a TypeScript program usually consists
of a large number of relatively simple functions.

   It should be clear that the possibility of associating values with
names and later retrieving them means that the compiler must
maintain some sort of memory that keeps track of the name-object pairs.
This memory is called the "environment" (more precisely the "global
environment", since we will see later that a computation may involve a
number of different environments).(2)

   ---------- Footnotes ----------

   (1) In this book, we do not show the compiler's response to
evaluating declarations, since this is highly implementation-dependent.

   (2) *Note Chapter 3:: will show that this notion of environment is
crucial, both for understanding how the compiler works and for
implementing compilers.


File: sicp-typescript.info,  Node: 1-1-3,  Next: 1-1-4,  Prev: 1-1-2,  Up: 1-1

1.1.3 Evaluating Combinations
------------------------

One of our goals in this chapter is to isolate issues about thinking
procedurally.  As a case in point, let us consider that, in evaluating
combinations, the TypeScript compiler is itself following a procedure.

     To evaluate a combination, do the following:

       1. Evaluate the subexpressions of the combination.

       2. Apply the function that is the value of the leftmost
          subexpression (the operator) to the arguments that are the
          values of the other subexpressions (the operands).

   Even this simple rule illustrates some important points about
processes in general.  First, observe that the first step dictates that
in order to accomplish the evaluation process for a combination we must
first perform the evaluation process on each element of the
combination.  Thus, the evaluation rule is "recursive" in nature; that
is, it includes, as one of its steps, the need to invoke the rule
itself.(1)

   Notice how succinctly the idea of recursion can be used to express
what, in the case of a deeply nested combination, would otherwise be
viewed as a rather complicated process.  For example, evaluating

      (3 * (2 + 4)) + (10 - 6))

requires that the evaluation rule be applied to four different
operations.  We can obtain a picture of this process by representing
the combination in the form of a tree, as shown in *Note Figure 1-1::.
Each combination is represented by a node with branches corresponding
to the operator and the operands of the combination stemming from it.
The terminal nodes (that is, nodes with no branches stemming from them)
represent either operators or numbers.  Viewing evaluation in terms of
the tree, we can imagine that the values of the operands percolate
upward, starting from the terminal nodes and then combining at higher
and higher levels.  In general, we shall see that recursion is a very
powerful technique for dealing with hierarchical, treelike objects.  In
fact, the "percolate values upward" form of the evaluation rule is an
example of a general kind of process known as "tree accumulation".

     *Figure 1.1:* Tree representation, showing the value of each
     subcombination.

             390
             /|\____________
            / |             \
           3*  26           15
              /|\             |
             / | \          // \\
            +  2  24       / |  | \
                 /|\      +  10 3  5  7
                / | \    
                * 4  6

   Next, observe that the repeated application of the first step brings
us to point where we need to evaluate, not combinations, but
primitive expressions such as numerals, built-in operators, or other
names.  We take care of the primitive cases by stipulating that

   * the values of numerals are the numbers that they name,

   * the values of built-in operators are the machine instruction
     sequences that carry out the corresponding operations, and

   * the values of other names are the objects associated with those
     names in the environment.

   We may regard the second rule as a special case of the third one by
stipulating that symbols such as `+' and `*' are also included in the
global environment, and are associated with the sequences of machine
instructions that are their "values."  The key point to notice is the
role of the environment in determining the meaning of the symbols in
expressions.  In an interactive language such as TypeScript, it is
meaningless to speak of the value of an expression such as `(x + 1)'
without specifying any information about the environment that would
provide a meaning for the symbol `x' (or even for the symbol `+').  As
we shall see in *Note Chapter 3::, the general notion of the
environment as providing a context in which evaluation takes place will
play an important role in our understanding of program execution.

   Notice that the evaluation rule given above does not handle
variable declarations.  For instance, evaluating `const x = 3' does not apply
assignment to two arguments, one of which is the value of the symbol `x'
and the other of which is 3, since the purpose of the declaration is
precisely to associate `x' with a value.  (That is, `const x = 3' is
not a combination in the sense we use for function application.)

   Such exceptions to the general evaluation rule are called forms
"special forms".  Variable declarations are the only example of a special form that
we have seen so far, but we will meet others shortly.  Each special
form has its own evaluation rule.  The various kinds of expressions
(each with its associated evaluation rule) constitute the syntax of the
programming language.  In comparison with most other programming
languages, TypeScript has a very simple syntax; that is, the evaluation rule
for expressions can be described by a simple general rule together with
specialized rules for a small number of special forms.(2)

   ---------- Footnotes ----------

   (1) It may seem strange that the evaluation rule says, as part of
the first step, that we should evaluate the leftmost element of a
combination, since at this point that can only be an operator such as
`+' or `*' representing a built-in primitive function such as addition
or multiplication.  We will see later that it is useful to be able to
work with combinations whose operators are themselves compound
expressions.

   (2) Special syntactic forms that are simply convenient alternative
surface structures for things that can be written in more uniform ways
are sometimes called "syntactic sugar", to use a phrase coined by Peter
Landin.  In comparison with users of other languages, TypeScript programmers,
as a rule, are less concerned with matters of syntax.  (By contrast,
examine any Java or C++ manual and notice how much of it is devoted to
descriptions of syntax.)  This disdain for syntax is due partly to the
flexibility of TypeScript, which makes it easy to change surface syntax, and
partly to the observation that many "convenient" syntactic constructs,
which make the language less uniform, end up causing more trouble than
they are worth when programs become large and complex.  In the words
of Alan Perlis, "Syntactic sugar causes cancer of the semicolon."


File: sicp-typescript.info,  Node: 1-1-4,  Next: 1-1-5,  Prev: 1-1-3,  Up: 1-1

1.1.4 Compound Functions
-------------------------

We have identified in TypeScript some of the elements that must appear in any
powerful programming language:

   * Numbers and arithmetic operations are primitive data and
     functions.

   * Nesting of combinations provides a means of combining operations.

   * Declarations that associate names with values provide a limited
     means of abstraction.


   Now we will learn about "function definitions", a much more powerful
abstraction technique by which a compound operation can be given a name
and then referred to as a unit.

   We begin by examining how to express the idea of "squaring."  We
might say, "To square something, multiply it by itself."  This is
expressed in our language as

      function square(x: number): number {
          return x * x;
      }

   We can understand this in the following way:

      function square(x: number) {         return      x         *    x;
         |         |            |      |         |
        |         |            |      |         |
       To      square  something,   multiply    it  by  itself.

   We have here a "compound function", which has been given to name
`square'.  The function represents the operation of multiplying
something by itself.  The thing to be multiplied is given a local name,
`x', which plays the same role that a pronoun plays in natural
language.  Evaluating the definition creates this compound function
and associates it with the name `square'.(1)

   The general form of a function definition in TypeScript is

      function <NAME>(<PARAMETERS>): <RETURN_TYPE> {
          <BODY>
      }

   The <NAME> is a symbol to be associated with the function
definition in the environment.(2) The <PARAMETERS> are names
used within the body of the function to refer to the corresponding
arguments of the function.  The <RETURN_TYPE> specifies the type of
value that the function returns.  The <BODY> is a block of statements
that will yield the value of the function application when the formal parameters
are replaced by the actual arguments to which the function is
applied.(3)  The <NAME> and <PARAMETERS> are grouped within
parentheses, just as they would be in an actual call to the function
being defined.

   Having defined `square', we can now use it:

      square(21)
      441

      square(2 + 5)
      49

      square(square(3))
      81

   We can also use `square' as a building block in defining other
functions.  For example, x^2 + y^2 can be expressed as

      square(x) + square(y)

   We can easily define a function `sumOfSquares' that, given any two
numbers as arguments, produces the sum of their squares:

      function sumOfSquares(x: number, y: number): number {
          return square(x) + square(y);
      }
      
      sumOfSquares(3, 4)
      25

   Now we can use `sumOfSquares' as a building block in constructing
further functions:

      function f(a: number): number {
          return sumOfSquares(a + 1, a * 2);
      }

      f(5)
      136

   Compound functions are used in exactly the same way as primitive
functions.  Indeed, one could not tell by looking at the definition of
`sumOfSquares' given above whether `square' was built into the
compiler, like `+' and `*', or defined as a compound function.

   ---------- Footnotes ----------

   (1) Observe that there are two different operations being combined
here: we are creating the function, and we are giving it a name
`square'.  It is possible, indeed important, to be able to separate
these two notions--to create functions without naming them, and to
give names to functions that have already been created.  We will see
how to do this in section *Note 1-3-2::.

   (2) Throughout this book, we will describe the general syntax of
expressions by using italic symbols delimited by angle brackets--e.g.,
<NAME>--to denote the "slots" in the expression to be filled in when
such an expression is actually used.

   (3) More generally, the body of the function can be a sequence of
statements.  In this case, the compiler evaluates each statement
in sequence in turn and returns the value of the final expression
as the value of the function application.


File: sicp-typescript.info,  Node: 1-1-5,  Next: 1-1-6,  Prev: 1-1-4,  Up: 1-1

1.1.5 The Substitution Model for Function Application
------------------------------------------------------

To evaluate a combination whose operator names a compound function, the
TypeScript compiler follows much the same process as for combinations whose
operators name primitive functions, which we described in section
*Note 1-1-3::.  That is, the compiler evaluates the elements of the
combination and applies the function (which is the value of the
operator of the combination) to the arguments (which are the values of the
operands of the combination).

   We can assume that the mechanism for applying primitive functions
to arguments is built into the compiler.  For compound functions,
the application process is as follows:

      To apply a compound function to arguments, evaluate the body of
      the function with each formal parameter replaced by the
      corresponding argument.

   To illustrate this process, let's evaluate the combination

      f(5)

where `f' is the function defined in section *Note 1-1-4::.  We begin
by retrieving the body of `f':

      return sumOfSquares(a + 1, a * 2);

   Then we replace the formal parameter `a' by the argument 5:

      return sumOfSquares(5 + 1, 5 * 2);

   Thus the problem reduces to the evaluation of a combination with two
operands and an operator `sumOfSquares'.  Evaluating this combination
involves three subproblems.  We must evaluate the operator to get the
function to be applied, and we must evaluate the operands to get the
arguments.  Now `5 + 1' produces 6 and `5 * 2' produces 10, so we
must apply the `sumOfSquares' function to 6 and 10.  These values
are substituted for the formal parameters `x' and `y' in the body of
`sumOfSquares', reducing the expression to

      return square(6) + square(10);

   If we use the definition of `square', this reduces to

      return (6 * 6) + (10 * 10);

   which reduces by multiplication to

      return 36 + 100;

   and finally to

      return 136;

   The process we have just described is called the "substitution model"
for function application.  It can be taken as a model that determines
the "meaning" of function application, insofar as the functions in
this chapter are concerned.  However, there are two points that should
be stressed:

   * The purpose of the substitution is to help us think about function
     application, not to provide a description of how the compiler
     really works.  Typical compilers do not evaluate function
     applications by manipulating the text of a function to substitute
     values for formal parameters.  In practice, the "substitution"
     is accomplished by using a local environment for the formal
     parameters.  We will discuss this more fully in *Note Chapter 3::
     and *Note Chapter 4:: when we examine the implementation of a
     compiler in detail.

   * Over the course of this book, we will present a sequence of
     increasingly elaborate models of how compilers work,
     culminating with a complete implementation of a compiler and
     runtime system in *Note Chapter 5::.  The substitution model is only
     the first of these models--a way to get started thinking formally
     about the evaluation process.  In general, when modeling phenomena
     in science and engineering, we begin with simplified, incomplete
     models.  As we examine things in greater detail, these simple
     models become inadequate and must be replaced by more refined
     models.  The substitution model is no exception.  In particular,
     when we address in *Note Chapter 3:: the use of functions with
     "mutable data," we will see that the substitution model breaks
     down and must be replaced by a more complicated model of function
     application.(1)


Applicative order versus normal order
.....................................

According to the description of evaluation given in section *Note
1-1-3::, the compiler first evaluates the operator and operands and
then applies the resulting function to the resulting arguments.  This
is not the only way to perform evaluation.  An alternative evaluation
model would not evaluate the operands until their values were needed.
Instead it would first substitute operand expressions for parameters
until it obtained an expression involving only primitive operators, and
would then perform the evaluation.  If we used this method,
evaluation of `f(5)' would proceed according to the sequence of
expansions

      sumOfSquares(5 + 1, 5 * 2)

      return    square(5 + 1)      square(5 * 2))

      return    (* (5 + 1) (5 + 1))   (* (5 * 2) (5 * 2)))

followed by the reductions

      return         (* 6 6)             (* 10 10))

      return           36                   100)

                          136

   This gives the same answer as our previous evaluation model, but the
process is different.  In particular, the evaluations of `5 + 1' and
`5 * 2' are each performed twice here, corresponding to the reduction
of the expression `x * x' with `x' replaced respectively by `5 + 1'
and `5 * 2'.

   This alternative "fully expand and then reduce" evaluation method is
known as "normal-order evaluation", in contrast to the "evaluate
arguments and then apply" method that the compiler actually uses,
which is called "applicative-order evaluation".  It can be shown that,
for function applications that can be modeled using substitution
(including all of the functions in the first two chapters of this book)
and that yield legitimate values, normal-order and applicative-order
evaluation produce the same value.  (See *Note Exercise 1-5:: for an
instance of an "illegitimate" value where normal-order and
applicative-order evaluation do not give the same result.)

   TypeScript uses applicative-order evaluation, partly because of the
additional efficiency obtained from avoiding multiple evaluations of
expressions such as those illustrated with `5 + 1' and `5 * 2'
above and, more significantly, because normal-order evaluation becomes
much more complicated to deal with when we leave the realm of
functions that can be modeled by substitution.  On the other hand,
normal-order evaluation can be an extremely valuable tool, and we will
investigate some of its implications in *Note Chapter 3:: and *Note
Chapter 4::.(2)

   ---------- Footnotes ----------

   (1) Despite the simplicity of the substitution idea, it turns out to
be surprisingly complicated to give a rigorous mathematical definition
of the substitution process.  The problem arises from the possibility of
confusion between the names used for the formal parameters of a
function and the (possibly identical) names used in the expressions to
which the function may be applied.  Indeed, there is a long history of
erroneous definitions of "substitution" in the literature of logic and
programming semantics.  See Stoy 1977 for a careful discussion of
substitution.

   (2) In *Note Chapter 3:: we will introduce "stream processing",
which is a way of handling apparently "infinite" data structures by
incorporating a limited form of normal-order evaluation.  In section
*Note 4-2:: we will modify the TypeScript interpreter to produce a
normal-order variant of TypeScript.


File: sicp-typescript.info,  Node: 1-1-6,  Next: 1-1-7,  Prev: 1-1-5,  Up: 1-1

1.1.6 Conditional Expressions and Predicates
-------------------------------------------

The expressive power of the class of functions that we can define at
this point is very limited, because we have no way to make tests and to
perform different operations depending on the result of a test.  For
instance, we cannot define a function that computes the absolute value
of a number by testing whether the number is positive, negative, or
zero and taking different actions in different cases according to
the rule

           /
           |   x  if x > 0
     |x| = <   0  if x = 0
           |  -x  if x < 0
           \

   This construct is called a "case analysis", and there is a special
form in TypeScript for notating such a case analysis.  It is called `if-else'
or `switch` statements, and it is used as follows:

      function abs(x: number): number {
          if (x > 0) {
              return x;
          } else if (x === 0) {
              return 0;
          } else {
              return -x;
          }
      }

   The general form of a conditional expression is

      if (<PREDICATE>) {
          <CONSEQUENT>
      } else {
          <ALTERNATIVE>
      }

   consisting of the keyword `if' followed by a predicate
expression in parentheses, followed by a consequent block and an alternative block.

   Another way to write the absolute-value function is

      function abs(x: number): number {
          return x < 0 ? -x : x;
      }

   which uses the ternary operator, a compact form of conditional
that can be used when there are precisely two cases in case
analysis.

   The general form of a ternary expression is

      <PREDICATE> ? <CONSEQUENT> : <ALTERNATIVE>

   To evaluate an `if' expression, the compiler starts by evaluating
the <PREDICATE> part of the expression.  If the <PREDICATE>
evaluates to a true value, the compiler then evaluates the <CONSEQUENT>
and returns its value.  Otherwise it evaluates the <ALTERNATIVE> and
returns its value.

   In addition to primitive predicates such as `<', `===', and `>', there
are logical composition operations, which enable us to construct
compound predicates.  The three most frequently used are these:

   * `(<E1> && <E2> && ... && <EN>)'

     The compiler evaluates the expressions <E> one at a time, in
     left-to-right order.  If any <E> evaluates to false, the value of
     the `&&' expression is false, and the rest of the <E>'s are not
     evaluated.  If all <E>'s evaluate to true values, the value of the
     `&&' expression is the value of the last one.

   * `(<E1> || <E2> || ... || <EN>)'

     The compiler evaluates the expressions <E> one at a time, in
     left-to-right order.  If any <E> evaluates to a true value, that
     value is returned as the value of the `||' expression, and the
     rest of the <E>'s are not evaluated.  If all <E>'s evaluate to
     false, the value of the `||' expression is false.

   * `!(<E>)'

     The value of a `!' expression is true when the expression <E>
     evaluates to false, and false otherwise.

   Notice that `&&' and `||' are short-circuiting operators, not functions,
because subexpressions are not necessarily all evaluated.  `!' is an ordinary
function.

   As an example of how these are used, the condition that a number x
be in the range 5 < x < 10 may be expressed as

      (x > 5) && (x < 10)

   As another example, we can define a predicate to test whether one
number is greater than or equal to another as

      function greaterThanOrEqual(x: number, y: number): boolean {
          return (x > y) || (x === y);
      }

   or alternatively as

      function greaterThanOrEqual(x: number, y: number): boolean {
          return !(x < y);
      }

      *Exercise 1.1:* Below is a sequence of expressions.  What is the
     result printed by the interpreter in response to each expression?
     Assume that the sequence is to be evaluated in the order in which
     it is presented.

          10

          5 + 3 + 4

          9 - 1

          6 / 2

          (2 * 4) + (4 - 6)

          const a = 3;

          const b = a + 1;

          a + b * (a * b);

          a === b

          if ((b > a) && (b < (a * b))) {
              b;
          } else {
              a;
          }

          2 + (b > a ? b : a);

          ((a > b ? a : (b < a ? b : -1)) * (a + 1);

      *Exercise 1.2:* Translate the following expression into TypeScript
     notation:

           5 + 4 + (2 - (3 - (6 + 4/5)))
           -----------------------------
                  3(6 - 2)(2 - 7)

      *Exercise 1.3:* Define a function that takes three numbers as
     arguments and returns the sum of the squares of the two larger
     numbers.

      *Exercise 1.4:* Observe that our model of evaluation allows for
     combinations whose operators are compound expressions.  Use this
     observation to describe the behavior of the following function:

          function aPlusAbsB(a: number, b: number): number {
              return (b > 0 ? (a + b) : (a - b));
          }

      *Exercise 1.5:* Ben Bitdiddle has invented a test to determine
     whether the compiler he is faced with is using
     applicative-order evaluation or normal-order evaluation.  He
     defines the following two functions:

          function p(): never {
              return p();
          }

          function test(x: number, y: number): number {
              if (x === 0) {
                  return 0;
              } else {
                  return y;
              }
          }

      Then he evaluates the expression

          test(0, p())

      What behavior will Ben observe with a compiler that uses
     applicative-order evaluation?  What behavior will he observe with
     a compiler that uses normal-order evaluation?  Explain your
     answer.  (Assume that the evaluation rule for the special form
     `if' is the same whether the compiler is using normal or
     applicative order:  The predicate expression is evaluated first,
     and the result determines whether to evaluate the consequent or
     the alternative expression.)

   ---------- Footnotes ----------

   (1) "Interpreted as either true or false" means this:  In TypeScript,
there are two distinguished values that are denoted by the constants
`true' and `false'.  When the compiler checks a predicate's value, it
interprets `false' as false.  Any other value is treated as true.  (Thus,
providing `true' is logically unnecessary, but it is convenient.)  In
this book we will use names `true' and `false', which are associated
with values `true' and `false' respectively.

   (2) `Abs' also uses the "negation" operator `!', which, when used with
a single operand, as in `!x', indicates negation.

   (3) A minor difference between `if-else' and `switch' is that the
consequent part of each `case' in a `switch' may be a sequence of
statements.  If the corresponding condition is found to be true,
statements are executed in sequence and the value of the final statement in
the sequence is returned as the value of the `switch' statement.  In an `if-else'
expression, however, the consequent and alternative must be single
expressions.

      *Exercise 1.1:* Below is a sequence of expressions.  What is the
     result printed by the environment in response to each expression?
     Assume that the sequence is to be evaluated in the order in which
     it is presented.

          10

          5 + 3 + 4

          9 - 1

          6 / 2

          (2 * 4) + (4 - 6)

          const a = 3;

          const b = a + 1;

          a + b * (a * b);

          a === b

          if ((b > a) && (b < (a * b))) {
              b;
          } else {
              a;
          }

          2 + (b > a ? b : a);

          ((a > b ? a : (b < a ? b : -1)) * (a + 1);

      *Exercise 1.2:* Translate the following expression into TypeScript
     notation:

          5 + 4 + (2 - (3 - (6 + 4/5)))
           -----------------------------
                  3(6 - 2)(2 - 7)

      *Exercise 1.3:* Define a function that takes three numbers as
     arguments and returns the sum of the squares of the two larger
     numbers.

      *Exercise 1.4:* Observe that our model of evaluation allows for
     combinations whose operators are compound expressions.  Use this
     observation to describe the behavior of the following function:

          function aPlusAbsB(a: number, b: number): number {
              return (b > 0) ? (a + b) : (a - b));
          }

      *Exercise 1.5:* Ben Bitdiddle has invented a test to determine
     whether the compiler he is faced with is using
     applicative-order evaluation or normal-order evaluation.  He
     defines the following two functions:

          function p(): never {
              return p();
          }

          function test(x: number, y: number): number {
              if (x === 0) {
                  return 0;
              } else {
                  return y;
              }
          }

      Then he evaluates the expression

          test(0, p())

      What behavior will Ben observe with a compiler that uses
     applicative-order evaluation?  What behavior will he observe with
     a compiler that uses normal-order evaluation?  Explain your
     answer.  (Assume that the evaluation rule for the special form
     `if' is the same whether the compiler is using normal or
     applicative order: The predicate expression is evaluated first,
     and the result determines whether to evaluate the consequent or
     the alternative expression.)

   ---------- Footnotes ----------

   (1) "Interpreted as either true or false" means this:  In TypeScript,
there are two distinguished values that are denoted by the constants
`true' and `false'.  When the compiler checks a predicate's value, it
interprets `false' as false.  Any other value is treated as true.  (Thus,
providing `true' is logically unnecessary, but it is convenient.)  In
this book we will use names `true' and `false', which are associated
with values `true' and `false' respectively.

   (2) `Abs' also uses the "negation" operator `!', which, when used with
a single operand, as in `!x', indicates negation.

   (3) A minor difference between `if-else' and `switch' is that the
consequent part of each `case' in a `switch' may be a sequence of
statements.  If the corresponding condition is found to be true,
statements are executed in sequence and the value of the final statement in
the sequence is returned as the value of the `switch' statement.  In an `if-else'
expression, however, the consequent and alternative must be single
expressions. the
statements are executed in sequence and the value of the final statement in
the sequence is returned as the value of the `switch' statement.  In an `if-else'
expression, however, the consequent and alternative must be single
expressions.
